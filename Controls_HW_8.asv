%% Problem 1
% x = [phi delta phi_dot delta_dot];
% xdot = [phi_dot delta_dot phi_ddot delta_ddot];
% xdot = Ax + Bu
% y = delta = Cx + Du = [0 1 0 0]x + D[0]
v0 = 5;
[M, C1, K0, K2] = matricies();
[a_mat,b_mat,c_mat,d_mat] = generate_state_space_matricies(M, C1, K0, K2, v0);

%% 1a
P = ss(a_mat, b_mat, c_mat, d_mat);
P_tf = tf(P);
figure;
bode(P)

%% 1b
C_prime = 5; % from sisotool
P_prime_tf = feedback(P_tf, C_prime);
z = 2.1797;
p = [0 -1];
k = 0.6882;
C_final = zpk(z, p, k);
P_final = P_prime_tf;

%% 1c
v0_values = [4, 6];
figure;
hold on;
bode(P_final*C_final);

% Bodes
for i = 1:length(v0_values)

    v0_curr = v0_values(i);
    [curr_a_mat, curr_b_mat, curr_c_mat, curr_d_mat] = generate_state_space_matricies(M, C1, K0, K2, v0_curr);
    new_P = ss(curr_a_mat, curr_b_mat, curr_c_mat, curr_d_mat);
    new_P_tf = tf(new_P);
    bode(feedback(new_P_tf, C_prime)*C_final);
end

legend("v0 = 5 m/s", "v0 = 4 m/s", "v0 = 6 m/s");
hold off;

% Root Loci
figure;
hold on;
rlocus(P_final*C_final);


for i = 1:length(v0_values)

    v0_curr = v0_values(i);
    [curr_a_mat, curr_b_mat, curr_c_mat, curr_d_mat] = generate_state_space_matricies(M, C1, K0, K2, v0_curr);
    new_P = ss(curr_a_mat, curr_b_mat, curr_c_mat, curr_d_mat);
    new_P_tf = tf(new_P);
    rlocus(feedback(new_P_tf,C_prime)*C_final);

end

legend("v0 = 5 m/s", "v0 = 4 m/s", "v0 = 6 m/s");
hold off;

% From root loci, v = 6 has poles on the LHP making it still possible to
% just barely have a stable loop but with the defined K values the system is unstable, this is verified with
% sisotool. However for v = 4 those same poles are in the
% RHP so it is always unstable

%% 1d

v0_values = [4, 5, 6];
step_freq = 0.002;


for i = 1:length(v0_values)

    v0_curr = v0_values(i);
    [curr_a_mat, curr_b_mat, curr_c_mat, curr_d_mat] = generate_state_space_matricies(M, C1, K0, K2, v0_curr);
    new_P = ss(curr_a_mat, curr_b_mat, curr_c_mat, curr_d_mat);
    new_P_tf = tf(new_P);

    figure;
    step(feedback(feedback(new_P_tf,C_prime)*C_final, 1));
    legend("v0 = " + v0_curr + " m/s");
    title("Step Response");
end


%% Problem 2
clear i
% 2a
reachability_mat = [b_mat a_mat*b_mat a_mat^2*b_mat  a_mat^3*b_mat];
if rank(reachability_mat) == size(reachability_mat, 1)
    disp("This system is Reachable!")
end

% 2b
poles = [-2 -10 -1+i  -1-i];
ss_model = ss(a_mat, b_mat, c_mat, d_mat);
k_gains = place(a_mat, b_mat, poles);
placed_reachable_poles_a_mat = a_mat-b_mat*k_gains;
k_r = -1/(c_mat*inv(placed_reachable_poles_a_mat)*b_mat)

% 2c
step_freq = 0.002;
new_ss_model = ss(placed_reachable_poles_a_mat, b_mat, c_mat, d_mat);
step(new_ss_model*k_r*step_freq);

%% Problem 3
clear i
% 3a
observability_mat = [c_mat; c_mat*a_mat; c_mat*a_mat^2;  c_mat*a_mat^3];
if rank(observability_mat) == size(observability_mat, 1)
    disp("This system is Observable!")
end

% 3b
poles = [-4 -20 -2+2i -2-2i];
plant_ss_model = ss(a_mat, b_mat, c_mat, d_mat);
l_gains = place(a_mat', c_mat', poles);

% 3c
stacked_a_mat = [a_mat-b_mat*k_gains b_mat*k_gains;...
    zeros(4) a_mat-l_gains'*c_mat];
stacked_b_mat = [b_mat*k_r; zeros(4,1)];
stacked_c_mat = [c_mat zeros(1,4); -k_gains k_gains];
stacked_d_mat = [0; k_r];
fullstate_feedback_ss = ss(stacked_a_mat, stacked_b_mat, stacked_c_mat, stacked_d_mat);

% Step Response
T = 0:0.001:10;
reference_rad = 0.002;
U = reference_rad*ones(size(T));

IC = [0 0 0 0 0 0        0 0;...
    0 0 0 0 0 reference_rad/10 0 0];

[y1, tOut, x1] = lsim(fullstate_feedback_ss, U, T, IC(1,:)');
[y2, tOut, x2] = lsim(fullstate_feedback_ss, U, T, IC(2,:)');
figure;
hold on;
plot(tOut, y1(:,1));
plot(tOut, y2(:,1));
ylabel('Angle (rad)');

title('Step Response of a Second-Order System', "Steering Angle");
xlabel('Time (s)');
legend('\delta^h^a^t(0) =' + " " + string(IC(1,6)), '\delta^h^a^t(0) =' + " " + string(IC(2,6)));
hold off;

figure;
hold on;
plot(tOut, y1(:,2));
plot(tOut, y2(:,2));
ylabel('Torque (N*m)');

title('Step Response of a Second-Order System', "Torque Input");
xlabel('Time (s)');
legend('\delta^h^a^t(0) =' + " " + string(IC(1,6)), '\delta^h^a^t(0) =' + " " + string(IC(2,6)));
hold off;


%% 4
controller_d_mat = 0;
controller_ss = ss(a_mat-b_mat*k_gains-l_gains'*c_mat, l_gains', -k_gains, controller_d_mat);
controller_tf_cl = k_r*tf(controller_ss);
%controller_tf_cl = -k_gains*inv(s*eye(4) - (a_mat - b_mat*k_gains - l_gains'*c_mat))*l_gains';

open_loop_ss = controller_tf_cl/(1 + controller_tf_cl); % plus not negative because it's posive feedback
open_loop_fd = P_final*C_final;

use_nyqlog = true;

ss_tf = open_loop_ss;
fd_tf = open_loop_fd;

figure;
hold on;
bode(ss_tf);
bode(fd_tf);

[Gm_ss, PM_ss] = margin(ss_tf);
[Gm_fd, PM_fd] = margin(fd_tf);
legend("State Space, GM = " + string(Gm_ss) + ", PM = " + string(PM_ss), "Frequency Domain, GM = " + string(Gm_fd) + ", PM = " + string(PM_fd));
hold off;

if use_nyqlog
    figure;
    nyqlog(tf(ss_tf));
    figure;
    nyqlog(fd_tf);
else
    figure;
    nyquist(ss_tf);
    figure;
    nyquist(fd_tf);
end
legend("State Space", "Frequency Domain");
hold off;
